from collections import List

@value
struct FreeCellBoard:
    var card_positions: SIMD[DType.uint8, 64]   # 52-length array storing card positions but simd has to be power of 2 i.e. 64, Main representation used as dict keys
    var top_cards: SIMD[DType.uint8,8]        # Top cards in each column
    var bottom_cards: SIMD[DType.uint8,8]    # Bottom cards in each column
    var free_cells: SIMD[DType.uint8,4]       # Free cells (63 means empty)
    var home_cells: SIMD[DType.uint8,4]       # Home cells, tracks highest card per suit
    var next_home_cards: SIMD[DType.uint8,4] # Next desired card for each home cell
    var full_board: SIMD[DType.uint8,256] # dual representation, board representation is bigger but easier to find the new top card etc.

    # Fixed-size legal move lookup table
    var column_move_lookup_1: SIMD[DType.uint8,64]
    var column_move_lookup_2: SIMD[DType.uint8,64]

    var legal_moves_card: SIMD[DType.uint8,64]
    var legal_moves_target: SIMD[DType.uint8,64]
    var num_legal_moves: Int
    var num_cells_occupied: Int

    fn __init__(inout self):
        var range_2: UInt8 = 7
        # Initialize tensors with appropriate sizes
        self.card_positions = SIMD[DType.uint8, 64]() #Tensor[DType.uint8](TensorShape(52))  # 52 cards
        self.top_cards = SIMD[DType.uint8, 8]()       # 8 columns
        self.bottom_cards = SIMD[DType.uint8, 8]()       # 8 columns
        self.free_cells = SIMD[DType.uint8, 4]()      # 4 free cells
        self.home_cells = SIMD[DType.uint8, 4]()      # 4 home cells
        self.next_home_cards = SIMD[DType.uint8, 4]()  # Next expected home cards
        self.full_board = SIMD[DType.uint8, 256]()  # Move lookup table for each card

        self.column_move_lookup_1 = SIMD[DType.uint8, 64]()  # Move lookup table for each card
        self.column_move_lookup_2 = SIMD[DType.uint8, 64]()  # Move lookup table for each card
        self.legal_moves_card = SIMD[DType.uint8, 64]()  # legal move cards
        self.legal_moves_target = SIMD[DType.uint8, 64]()  # legal move target positions
        self.num_legal_moves = 0
        self.num_cells_occupied = 0

        # Initialize values (defining 63 as "empty")
        #var i: UInt8
        self.free_cells=63
        self.home_cells=63
        for i in range(4):
            self.next_home_cards[i]=i # last two digits are the suit since ace has value 0 the aces are  "0 00000 00" "0 00000 01" "0 00000 10" "0 00000 11" i.E. range(4)
        var k: Int =0
        self.full_board=63

        for i in range(8):
            
            
            if i==4:
                range_2=6
            for j in range(range_2):
                
                self.card_positions[k]= i*32+j
                k+=1
                self.full_board[i*32+j]=k
                if j==0:
                    self.bottom_cards[i]=i*32+j
                if j==range_2.__int__()-1:
                    self.top_cards[i]=i*32+j
            

        # Generate the lookup table
        self.generate_column_move_lookup()

    fn __init__(inout self, card_input: String):
        """Overloaded initializer with card input."""
        self.__init__()  # Start with default init
        self.parse_input(card_input)

    fn parse_input(inout self, card_input: String):
        """Parse input string of cards and initialize board."""
        var card_strings: List[String]
        try:
            card_strings = card_input.split(" ")
        except:
            print("unable to parse input")
            return
        for i in range(len(card_strings)):
            var card_pos : UInt8 = (i%8*32)+i//8  #i%8 is the collumn i//8 is the position
            var card_index : Int = self.get_card_index(card_strings[i]).__int__()
            #print(i,i%8,i//8,card_index)
            if i<8:
                self.bottom_cards[i]= card_index
            elif i >= 52:
                break
            elif i >= 52-4:
                self.top_cards[i-52+4] = card_index
            elif i >= 52-8:
                self.top_cards[i-52+12] = card_index
            self.card_positions[card_index] = card_pos
            self.full_board[card_pos.__int__()]=card_index



    fn generate_column_move_lookup(inout self):
        """Pregenerate legal column moves for each card."""
        var value: UInt8
        var suit: UInt8
        var color: UInt8
        var other_value: UInt8
        var other_suit: UInt8
        var other_color: UInt8
        var legal_moves: UInt8
        for card_index in range(52):
            value, suit, color = self.get_card_value(card_index)
            if value==12: #king
                self.column_move_lookup_1[card_index]=self.get_card_index(13,0,0) #value 13 does not exist, king has no legal collumn move
                self.column_move_lookup_1[card_index]=self.get_card_index(13,0,0) #value 13 does not exist, king has no legal collumn move
                continue
            # Every card has two legal move options (opposite color, one rank higher)
            legal_moves = 0
            for other_card_index in range(52):
                other_value, other_suit, other_color = self.get_card_value(other_card_index)
                if other_value == value + 1 and other_color != color:
                    if legal_moves == 0:
                        self.column_move_lookup_1[card_index] = other_card_index
                        legal_moves += 1
                    elif legal_moves == 1:
                        self.column_move_lookup_2[card_index] = other_card_index
                        break
                        

    fn generate_all_legal_moves(inout self):
        """Generate all legal moves based on current board state."""
        var move_count: Int=0
        self.legal_moves_card=63
        self.legal_moves_target=0
        
        # Free Cell Moves: If there is an empty free cell, move all top cards and free cell cards
        var empty_free_cell: UInt8 = 99
        for i in range(4):
            if self.free_cells[i] == 63:
                empty_free_cell = i
                break
        
        if empty_free_cell != 99:
            # Move all top cards from columns to the free cell
            for top_card_i in range(8):
                if self.top_cards[top_card_i] != 63:
                    self.legal_moves_card[move_count] = self.top_cards[top_card_i] 
                    self.legal_moves_target[move_count]= 30+(self.num_cells_occupied*32)  # Move to free cell (index 30) and collumn 0-3 representing each cell
                    move_count += 1

        # Home Cell Moves
        var movable_cards= SIMD[DType.uint8, 16]()
        for i in range(8):
            movable_cards[i]=self.top_cards[i]
        for i in range(4):
            movable_cards[i+8]=self.free_cells[i]
        var card: UInt8
        var value:UInt8
        var suit: UInt8
        var color: UInt8
        for card_i in range(12):
            card=movable_cards[card_i]
            if card != 63:
                value, suit, color = self.get_card_value(card)
                if card == self.next_home_cards[(2*suit+color).__int__()]:
                    self.legal_moves_card[move_count] = card
                    self.legal_moves_target[move_count] = 31+color*32+suit*64# Move to home cell (index 31) and collumn 0-3 representing color
                    move_count += 1

        # Column Moves
        for col_idx in range(8):
            var top_card = self.top_cards[col_idx]

            # If the column is empty, move any card to this empty column
            if top_card == 63:  
                for card_i in range(12):
                    card=movable_cards[card_i]
                    if card != 63:
                        self.legal_moves_card[move_count] = card
                        self.legal_moves_target[move_count] = col_idx << 5
                        move_count += 1
                break  # Stop the loop, since all following columns will also be empty

            # Otherwise, check if any other card can be moved onto this top card
            else:
                for card_i in range(12):
                    card=movable_cards[card_i]
                    if card != 63:
                        # Check if the top card is a legal move option for the current card
                        var move_option_1 = self.column_move_lookup_1[card.__int__()]
                        var move_option_2 = self.column_move_lookup_2[card.__int__()]
                        
                        if move_option_1 == top_card or move_option_2 == top_card:  # Valid move to this column
                            self.legal_moves_card[move_count] = card
                            self.legal_moves_target[move_count] = self.card_positions[top_card.__int__()] + 1
                            move_count += 1
        self.num_legal_moves=move_count
    fn canonicalize_position(inout self):
        """Canonicalize the position by sorting columns and free cells."""
        # Step 1: Sort Columns based on the index of the bottom card
        var new_bottom_cards = self.bottom_cards
        var sorted = False
        var temp_card:UInt8
        # Create a mapping from old to new column indices
        var col_mapping: SIMD[DType.uint8,8]  = SIMD[DType.uint8,8](0,1,2,3,4,5,6,7)
        var temp_card_i:UInt8
        while not sorted:
            sorted=True
            for i in range(7):
                if new_bottom_cards[i]>new_bottom_cards[i+1]:
                    temp_card=new_bottom_cards[i]
                    new_bottom_cards[i]=new_bottom_cards[i+1]
                    new_bottom_cards[i+1]=temp_card

                    temp_card_i=col_mapping[i]
                    col_mapping[i]=col_mapping[i+1]
                    col_mapping[i+1]=temp_card_i

                    sorted =False

        var new_top_cards = SIMD[DType.uint8, 8]()
        var new_columns = List[List[UInt8]](capacity=8)
        
        for i in range(8):
            new_top_cards[i] = self.top_cards[col_mapping[i].__int__()]
            
            
        
        # Step 2: Sort Free Cells based on card indices
        var free_cell_info = List[Tuple[UInt8, UInt8]]()
        for old_free_cell_idx in range(4):
            var card_index = self.free_cells[old_free_cell_idx]
            free_cell_info.append((card_index, old_free_cell_idx))
        
        free_cell_info.sort(key=lambda x: x[0])
        var free_cell_mapping = Dict[UInt8, UInt8]()
        var new_free_cells = SIMD[DType.uint8, 4]()
        
        for new_free_cell_idx in range(4):
            var (card_index, old_free_cell_idx) = free_cell_info[new_free_cell_idx]
            free_cell_mapping[old_free_cell_idx] = new_free_cell_idx
            new_free_cells[new_free_cell_idx] = card_index
        
        # Update attributes
        self.top_cards = new_top_cards
        self.bottom_cards = new_bottom_cards
        self.free_cells = new_free_cells
        
        # Step 3: Update card_positions
        for card_index in range(52):
            var pos = self.card_positions[card_index]
            var old_column_index = pos >> 5
            var position_in_column = pos & 0b11111
            
            if position_in_column < 30:
                # Card is in a column
                var new_column_index = col_mapping[old_column_index]
                var new_pos = (new_column_index << 5) + position_in_column
                self.card_positions[card_index] = new_pos
            elif position_in_column == 30:
                # Card is in a free cell
                if old_column_index < 4:
                    var old_free_cell_idx = old_column_index
                    var new_free_cell_idx = free_cell_mapping[old_free_cell_idx]
                    var new_pos = (new_free_cell_idx << 5) + position_in_column
                    self.card_positions[card_index] = new_pos
            # Home cells and other positions remain unchanged
        
        # Step 4: Rebuild full_board
        self.full_board = 63  # Reset to "no card"
        for card_index in range(52):
            var pos = self.card_positions[card_index]
            self.full_board[pos.__int__()] = card_index
        
        # Step 5: Update legal_moves_target
        for i in range(self.num_legal_moves):
            var target = self.legal_moves_target[i]
            var old_column_index = target >> 5
            var position_in_column = target & 0b11111
            
            if position_in_column < 30:
                # Target is a column position
                var new_column_index = col_mapping[old_column_index]
                var new_target = (new_column_index << 5) + position_in_column
                self.legal_moves_target[i] = new_target
            elif position_in_column == 30:
                # Target is a free cell
                if old_column_index < 4:
                    var old_free_cell_idx = old_column_index
                    var new_free_cell_idx = free_cell_mapping[old_free_cell_idx]
                    var new_target = (new_free_cell_idx << 5) + position_in_column
                    self.legal_moves_target[i] = new_target
            # Home cells and other positions remain unchanged       

    fn get_card_value(inout self,card_index: UInt8) -> (UInt8, UInt8, UInt8):
        """Extract the value, suit, and color from the card index."""
        var value: UInt8 = (card_index >> 2) & 2**4-1   # Extract 4 bits for value
        var suit: UInt8 = (card_index >> 1) & 2**1-1  # Extract 1 bit for suit
        var color: UInt8 = (card_index) & 2**1-1  # Extract 1 bit for color
        return (value, suit, color)
    fn get_card_index(inout self, value:UInt8, suit:UInt8,color:UInt8) -> UInt8:
        var card_index: UInt8 = value*4 +suit*2+color
        #var value_t: UInt8 = (card_index >> 2) & 2**4-1   # Extract 4 bits for value
        #var suit_t: UInt8 = (card_index >> 1) & 2**1-1    # Extract 1 bit for suit
        #var color_t: UInt8 = (card_index) & 2**1-1  # Extract 1 bit for color
        #print(card_index,value_t,suit_t,color_t)
        return card_index


    fn get_card_index(inout self, card_string:String) -> UInt8:
        var value: UInt8
        var suit: UInt8
        var color: UInt8
        var value_letter: String = card_string[0]
        var suit_letter: String = card_string[1]
        #print(card_string)
        if value_letter=="A":
            value=0
        elif value_letter=="T":
            value=9
        elif value_letter=="J":
            value=10
        elif value_letter=="Q":
            value=11
        elif value_letter=="K":
            value=12
        else:
            try:
                value=int(value_letter)-1
            except:
                value=0
                print("Warning could not read card value")
        if suit_letter=="S":
            suit=0
            color=0
        elif suit_letter=="H":
            suit=0
            color=1
        elif suit_letter=="C":
            suit=1
            color=0
        elif suit_letter=="D":
            suit=1
            color=1
        else:
            suit=0
            color=0
            print("Warning could not read suit value")
        return self.get_card_index(value,suit,color)


fn main():
    var board = FreeCellBoard("7D AH AS TD 6C TC JH AC 2S 4H 2C 3C TH 5H 9C 7H 9H KH 3H AD 9D 8S JD 7C 5C 4D 8C 6D QS 5D KS 7S 9S 8D JC 6H 4S 3S QH 2D TS QD 8H QC 2H 6S JS KC 3D KD 4C 5S")
    var cards: SIMD[DType.uint8, 64]
    var targets: SIMD[DType.uint8, 64]
    var top_cards: SIMD[DType.uint8, 8]
    var moves_found: Int
    var value: UInt8
    var suit: UInt8
    var color: UInt8
    board.generate_all_legal_moves()
    top_cards= board.top_cards
    for i in range (8):
        value,suit,color=board.get_card_value(top_cards[i])
        print("card",value,suit,color)
        value,suit,color=board.get_card_value(board.column_move_lookup_1[top_cards[i].__int__()])
        print("target",value,suit,color)
    print(board.num_legal_moves)
    for i in range (board.num_legal_moves):
        value,suit,color=board.get_card_value(board.legal_moves_target[i])
        print(value,suit,color)
        print(board.legal_moves_target[i])
    print(board.card_positions)
    print(board.full_board)
